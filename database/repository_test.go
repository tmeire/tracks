package database

import (
	"context"
	"database/sql"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"testing"
)

// TestToSnakeCase tests the toSnakeCase function with various inputs
func TestToSnakeCase(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "Empty string",
			input:    "",
			expected: "",
		},
		{
			name:     "Single lowercase word",
			input:    "hello",
			expected: "hello",
		},
		{
			name:     "Single uppercase word",
			input:    "HELLO",
			expected: "hello",
		},
		{
			name:     "Camel case",
			input:    "helloWorld",
			expected: "hello_world",
		},
		{
			name:     "Pascal case",
			input:    "HelloWorld",
			expected: "hello_world",
		},
		{
			name:     "Multiple uppercase letters in sequence",
			input:    "HTTPRequest",
			expected: "http_request",
		},
		{
			name:     "Already snake case",
			input:    "hello_world",
			expected: "hello_world",
		},
		{
			name:     "Mixed case with numbers",
			input:    "User123Name",
			expected: "user123_name",
		},
		{
			name:     "Trailing uppercase group",
			input:    "LocationID",
			expected: "location_id",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := toSnakeCase(tt.input)
			assert.Equal(t, tt.expected, result, "toSnakeCase(%q) should equal %q", tt.input, tt.expected)
		})
	}
}

// TestModel is a test model that implements the Model interface for testing deconstruct
type TestModel struct {
	Model[*TestModel] `tracks:"test_models"`
	ID                int    `tracks:"id,primarykey,autogen"`
	Name              string `tracks:"name"`
	Email             string `tracks:"email,omitempty"`
	Ignored           string `tracks:"-"`
	LocationID        int    `tracks:"location_id,foreignkey,omitempty"`
	NoTag             string
}

func (m *TestModel) Scan(row Scanner) (*TestModel, error) {
	var zero TestModel
	return &zero, nil
}

func (m TestModel) HasAutoIncrementID() bool {
	return true
}

func (m TestModel) GetID() any {
	return m.ID
}

// TestDeconstruct tests the deconstruct function
func TestDeconstruct(t *testing.T) {
	expected := DD[*TestModel]{
		TableName: "test_models",
		Fields: []field{
			{
				Index:         1,
				Name:          "id",
				PrimaryKey:    true,
				Autogenerated: true,
				OmitEmpty:     false,
			},
			{
				Index:         2,
				Name:          "name",
				PrimaryKey:    false,
				Autogenerated: false,
				OmitEmpty:     false,
			},
			{
				Index:         3,
				Name:          "email",
				PrimaryKey:    false,
				Autogenerated: false,
				OmitEmpty:     true,
			},
			{
				Index:         5,
				Name:          "no_tag",
				PrimaryKey:    false,
				Autogenerated: false,
				OmitEmpty:     false,
			},
			{
				Index:         6,
				Name:          "location_id",
				PrimaryKey:    false,
				Autogenerated: false,
				OmitEmpty:     false,
			},
		},
		FieldNames: []string{"id", "name", "email", "no_tag", "location_id"},
		ID: field{
			Index:         1,
			Name:          "id",
			PrimaryKey:    true,
			Autogenerated: true,
			OmitEmpty:     false,
		},
	}

	result := deconstruct[*TestModel]()

	// Check TableName
	assert.Equal(t, expected.TableName, result.TableName, "TableName should match")

	// Check Fields length
	assert.Len(t, result.Fields, len(expected.Fields), "Fields length should match")

	// Check each field
	for i, expectedField := range expected.Fields {
		assert.Equal(t, expectedField.Index, result.Fields[i].Index, "Field[%d].Index should match", i)
		assert.Equal(t, expectedField.Name, result.Fields[i].Name, "Field[%d].Name should match", i)
		assert.Equal(t, expectedField.PrimaryKey, result.Fields[i].PrimaryKey, "Field[%d].PrimaryKey should match", i)
		assert.Equal(t, expectedField.Autogenerated, result.Fields[i].Autogenerated, "Field[%d].Autogenerated should match", i)
		assert.Equal(t, expectedField.OmitEmpty, result.Fields[i].OmitEmpty, "Field[%d].OmitEmpty should match", i)
	}

	// Check FieldNames
	assert.Equal(t, expected.FieldNames, result.FieldNames, "FieldNames should match")

	// Check ID field
	assert.Equal(t, expected.ID.Index, result.ID.Index, "ID.Index should match")
	assert.Equal(t, expected.ID.Name, result.ID.Name, "ID.Name should match")
	assert.Equal(t, expected.ID.PrimaryKey, result.ID.PrimaryKey, "ID.PrimaryKey should match")
	assert.Equal(t, expected.ID.Autogenerated, result.ID.Autogenerated, "ID.Autogenerated should match")
	assert.Equal(t, expected.ID.OmitEmpty, result.ID.OmitEmpty, "ID.OmitEmpty should match")
}

type MockDatabase struct {
	mock.Mock
}

func (m MockDatabase) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) {
	res := m.Called(ctx, query, args)
	return res.Get(0).(*sql.Rows), res.Error(1)
}

func (m MockDatabase) QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row {
	res := m.Called(ctx, query, args)
	return res.Get(0).(*sql.Row)
}

func (m MockDatabase) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	res := m.Called(ctx, query, args)
	return nil, res.Error(1)
}

func (m MockDatabase) Close() error {
	return m.Called().Error(0)
}

func TestRepository_Update(t *testing.T) {
	// Create mock database
	mockDB := new(MockDatabase)
	mockDB.On("ExecContext",
		mock.Anything,
		"UPDATE test_models SET name = ?, email = ?, no_tag = ? WHERE id = ?",
		[]interface{}{"New Name", "who@example.com", "value", 1},
	).Return(sql.Result(nil), nil).Once()

	ctx := WithDB(context.Background(), mockDB)

	r := NewRepository[*TestModel]()
	err := r.Update(ctx, &TestModel{ID: 1, Name: "New Name", Email: "who@example.com", Ignored: "nope", NoTag: "value"})

	assert.NoError(t, err)
	mockDB.AssertExpectations(t)
}
