package database

import (
	"context"
	"fmt"
	"reflect"
	"slices"
	"strings"

	"go.opentelemetry.io/otel"
)

type DD[T Model[T]] struct {
	TableName  string
	Fields     []field
	FieldNames []string
	ID         field
}

type field struct {
	// index of the field in the struct
	Index int
	// name of the field in the database
	Name string
	// true if the field is the primary key of the table
	PrimaryKey bool
	// true if the value of the field is generated by the database
	Autogenerated bool
	// true if the field should be skipped when zero
	OmitEmpty bool
}

func toSnakeCase(s string) string {
	var sb strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			sb.WriteRune('_')
		}
		sb.WriteRune(r)
	}
	return strings.ToLower(sb.String())
}

func deconstruct[T Model[T]]() DD[T] {
	var zero T
	t := reflect.TypeOf(zero)
	if t.Kind() == reflect.Pointer {
		t = t.Elem()
	}

	dd := DD[T]{}

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		tag := strings.TrimSpace(f.Tag.Get("tracks"))

		if f.Name == "Model" {
			dd.TableName = toSnakeCase(tag)
			continue
		}

		// ignore this field
		if tag == "-" {
			continue
		}

		ddf := field{
			Index: i,
		}

		flags := strings.Split(strings.TrimSpace(tag), ",")
		if len(flags) >= 1 && flags[0] != "" {
			f.Name = flags[0]
		}

		if slices.Contains(flags, "primarykey") {
			ddf.PrimaryKey = true
			dd.ID = ddf
		}
		if slices.Contains(flags, "autogen") {
			ddf.Autogenerated = true
		}
		if slices.Contains(flags, "omitempty") {
			ddf.OmitEmpty = true
		}

		dd.Fields = append(dd.Fields, ddf)
		dd.FieldNames = append(dd.FieldNames, f.Name)
	}
	return dd
}

// Repository provides CRUD operations for a specific model type
type Repository[T Model[T]] struct {
	dd DD[T]
}

// NewRepository creates a new repository for the given model type
func NewRepository[T Model[T]]() *Repository[T] {
	return &Repository[T]{
		dd: deconstruct[T](),
	}
}

// Select creates a new QueryBuilder with the specified fields
func (r *Repository[T]) Select(fields ...string) WhereableQuery[T] {
	// TODO: validate the fields list against the list in the dd
	return &QueryBuilder[T]{
		fields:    fields,
		tableName: r.dd.TableName,
	}
}

// FindBy retrieves records that match the given search criteria.
func (r *Repository[T]) FindBy(ctx context.Context, criteria map[string]any) ([]T, error) {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.findby")
	defer span.End()

	q := r.Select()

	for field, value := range criteria {
		q = q.Where(fmt.Sprintf("%s = ?", field), value)
	}

	return q.Execute(ctx)
}

// FindAll retrieves all records of the model type from the database
func (r *Repository[T]) FindAll(ctx context.Context) ([]T, error) {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.findall")
	defer span.End()

	return r.Select().Execute(ctx)
}

// FindByID retrieves a record by its ID
func (r *Repository[T]) FindByID(ctx context.Context, id any) (T, error) {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.findbyid")
	defer span.End()

	return r.Select().Where("id = ?", id).First(ctx)
}

// Create inserts a new record into the database	q
func (r *Repository[T]) Create(ctx context.Context, model T) (T, error) {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.create")
	defer span.End()

	var fields []string
	var values []any
	var idValue any

	// TODO: Can we somehow do this without reflection?
	val := reflect.ValueOf(model)
	if val.Type().Kind() == reflect.Pointer {
		val = val.Elem()
	}
	for _, f := range r.dd.Fields {
		fval := val.Field(f.Index)
		if !f.Autogenerated && !(f.OmitEmpty && fval.IsZero()) {
			fields = append(fields, f.Name)
			values = append(values, fval.Interface())
		}
		if f == r.dd.ID {
			idValue = fval.Interface()
		}
	}

	// Create placeholders for the SQL query
	placeholders := make([]string, len(fields))
	for i := range placeholders {
		placeholders[i] = "?"
	}

	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)",
		r.dd.TableName,
		strings.Join(fields, ", "),
		strings.Join(placeholders, ", "))

	res, err := FromContext(ctx).ExecContext(ctx, query, values...)
	if err != nil {
		var zero T
		return zero, err
	}

	// For auto-increment IDs, retrieve the ID from the database
	if !r.dd.ID.Autogenerated {
		// For app-provided IDs, use the ID from the model
		return r.FindByID(ctx, idValue)
	}

	id, err := res.LastInsertId()
	if err != nil {
		var zero T
		return zero, err
	}
	return r.FindByID(ctx, id)
}

// Update updates an existing record in the database
func (r *Repository[T]) Update(ctx context.Context, model T) error {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.update")
	defer span.End()

	var fields []string
	var values []any
	var idValue any

	// TODO: Can we somehow do this without reflection?
	val := reflect.ValueOf(model)
	if val.Type().Kind() == reflect.Pointer {
		val = val.Elem()
	}
	for _, f := range r.dd.Fields {
		fval := val.Field(f.Index)
		if !f.Autogenerated && !(f.OmitEmpty && fval.IsZero()) {
			fields = append(fields, f.Name)
			values = append(values, fval.Interface())
		}
		if f == r.dd.ID {
			idValue = fval.Interface()
		}
	}

	// Build SET clause for all fields
	var setClause []string
	var args []any

	for i, field := range fields {
		setClause = append(setClause, fmt.Sprintf("%s = ?", field))
		args = append(args, values[i])
	}

	query := fmt.Sprintf("UPDATE %s SET %s WHERE id = ?",
		r.dd.TableName,
		strings.Join(setClause, ", "))

	// Add ID as the last argument for the WHERE clause
	args = append(args, idValue)

	_, err := FromContext(ctx).ExecContext(ctx, query, args...)
	return err
}

// Delete removes a record from the database
func (r *Repository[T]) Delete(ctx context.Context, model T) error {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.delete")
	defer span.End()

	query := fmt.Sprintf("DELETE FROM %s WHERE id = ?", r.dd.TableName)

	v := reflect.ValueOf(model)
	if v.Type().Kind() == reflect.Pointer {
		v = v.Elem()
	}

	_, err := FromContext(ctx).ExecContext(ctx, query, v.Field(r.dd.ID.Index).Interface())
	return err
}

// Count returns the total number of records in the table
func (r *Repository[T]) Count(ctx context.Context) (int, error) {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.count")
	defer span.End()

	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", r.dd.TableName)

	rows, err := FromContext(ctx).QueryContext(ctx, query)
	if err != nil {
		return 0, err
	}
	defer rows.Close()

	if !rows.Next() {
		return 0, fmt.Errorf("failed to get count from %s", r.dd.TableName)
	}

	var count int
	if err := rows.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}
