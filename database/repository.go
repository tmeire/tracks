package database

import (
	"context"
	"fmt"
	"reflect"
	"slices"
	"strings"

	"go.opentelemetry.io/otel"
)

type DD[T Model[T]] struct {
	TableName  string
	Fields     []*field
	FieldNames []string
	ID         *field
}

type field struct {
	// index of the field in the struct
	Index int
	// name of the field in the database
	Name string
	// true if the field is the primary key of the table
	PrimaryKey bool
	// true if the value of the field is generated by the database
	Autogenerated bool
	// true if the field should be skipped when zero
	OmitEmpty bool
}

func toSnakeCase(s string) string {
	// Special case: if the entire string is uppercase, just convert to lowercase
	allUpper := true
	for _, r := range s {
		if r < 'A' || r > 'Z' {
			allUpper = false
			break
		}
	}
	if allUpper {
		return strings.ToLower(s)
	}

	var sb strings.Builder
	for i, r := range s {
		// Add underscore before uppercase letters, but only if:
		// 1. It's not the first character
		// 2. The previous character is not uppercase or the next character is not uppercase
		//    (to handle sequences like "HTTP" correctly)
		if i > 0 && r >= 'A' && r <= 'Z' {
			prev := rune(s[i-1])
			isNextUpper := i+1 == len(s) || (i+1 < len(s) && s[i+1] >= 'A' && s[i+1] <= 'Z')
			isPrevUpper := prev >= 'A' && prev <= 'Z'

			if !isPrevUpper || !isNextUpper {
				sb.WriteRune('_')
			}
		}
		sb.WriteRune(r)
	}
	return strings.ToLower(sb.String())
}

func deconstruct[T Model[T]]() DD[T] {
	var zero T
	t := reflect.TypeOf(zero)
	if t.Kind() == reflect.Pointer {
		t = t.Elem()
	}

	dd := DD[T]{}

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		tag := strings.TrimSpace(f.Tag.Get("tracks"))

		if f.Name == "Model" {
			dd.TableName = toSnakeCase(tag)
			continue
		}

		// ignore this field
		if tag == "-" {
			continue
		}

		ddf := &field{
			Index: i,
		}

		flags := strings.Split(strings.TrimSpace(tag), ",")
		if len(flags) >= 1 && flags[0] != "" {
			ddf.Name = flags[0]
		} else {
			ddf.Name = toSnakeCase(f.Name)
		}

		isPrimaryKey := false
		if slices.Contains(flags, "primarykey") {
			ddf.PrimaryKey = true
			isPrimaryKey = true
		}
		if slices.Contains(flags, "autogen") {
			ddf.Autogenerated = true
		}
		if slices.Contains(flags, "omitempty") {
			ddf.OmitEmpty = true
		}

		// Set the ID field after all flags have been processed
		if isPrimaryKey {
			dd.ID = ddf
		}

		dd.Fields = append(dd.Fields, ddf)
		dd.FieldNames = append(dd.FieldNames, ddf.Name)
	}
	if dd.ID == nil {
		found := false
		for _, f := range dd.Fields {
			if f.Name == "id" {
				dd.ID = f
				dd.ID.PrimaryKey = true
				dd.ID.Autogenerated = true
				found = true
				break
			}
		}
		if !found {
			panic("no primary key field found")
		}
	}
	if dd.TableName == "" {
		panic("no table name specified")
	}
	return dd
}

// Repository provides CRUD operations for a specific model type
type Repository[T Model[T]] struct {
	dd DD[T]
}

// NewRepository creates a new repository for the given model type
func NewRepository[T Model[T]]() *Repository[T] {
	return &Repository[T]{
		dd: deconstruct[T](),
	}
}

// Select creates a new QueryBuilder with the specified fields
// If no fields are specified, all fields that are defined in the struct are selected.
func (r *Repository[T]) Select(fields ...string) WhereableQuery[T] {
	if len(fields) == 0 {
		fields = r.dd.FieldNames
	}
	// TODO: validate the fields list against the list in the dd
	return &QueryBuilder[T]{
		fields:    fields,
		tableName: r.dd.TableName,
	}
}

// FindBy retrieves records that match the given search criteria.
func (r *Repository[T]) FindBy(ctx context.Context, criteria map[string]any) ([]T, error) {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.findby")
	defer span.End()

	q := r.Select()

	for field, value := range criteria {
		q = q.Where(fmt.Sprintf("%s = ?", field), value)
	}

	return q.Execute(ctx)
}

// FindAll retrieves all records of the model type from the database
func (r *Repository[T]) FindAll(ctx context.Context) ([]T, error) {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.findall")
	defer span.End()

	return r.Select().Execute(ctx)
}

// FindByID retrieves a record by its ID
func (r *Repository[T]) FindByID(ctx context.Context, id any) (T, error) {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.findbyid")
	defer span.End()

	return r.Select().Where("id = ?", id).First(ctx)
}

// Create inserts a new record into the database	q
func (r *Repository[T]) Create(ctx context.Context, model T) (T, error) {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.create")
	defer span.End()

	var fields []string
	var values []any
	var idValue any

	// TODO: Can we somehow do this without reflection?
	val := reflect.ValueOf(model)
	if val.Type().Kind() == reflect.Pointer {
		val = val.Elem()
	}
	for _, f := range r.dd.Fields {
		fval := val.Field(f.Index)
		if !f.Autogenerated && !(f.OmitEmpty && fval.IsZero()) {
			fields = append(fields, f.Name)
			values = append(values, fval.Interface())
		}
		if f == r.dd.ID {
			idValue = fval.Interface()
		}
	}

	// Create placeholders for the SQL query
	placeholders := make([]string, len(fields))
	for i := range placeholders {
		placeholders[i] = "?"
	}

	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)",
		r.dd.TableName,
		strings.Join(fields, ", "),
		strings.Join(placeholders, ", "))

	res, err := FromContext(ctx).ExecContext(ctx, query, values...)
	if err != nil {
		var zero T
		return zero, err
	}

	// For auto-increment IDs, retrieve the ID from the database
	if !r.dd.ID.Autogenerated {
		// For app-provided IDs, use the ID from the model
		return r.FindByID(ctx, idValue)
	}

	id, err := res.LastInsertId()
	if err != nil {
		var zero T
		return zero, err
	}
	return r.FindByID(ctx, id)
}

// Update updates an existing record in the database
func (r *Repository[T]) Update(ctx context.Context, model T) error {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.update")
	defer span.End()

	var setClause []string
	var args []any
	var idValue any

	// TODO: Can we somehow do this without reflection and without a lot of boilerplate?
	val := reflect.ValueOf(model)
	if val.Type().Kind() == reflect.Pointer {
		val = val.Elem()
	}
	for _, f := range r.dd.Fields {
		fval := val.Field(f.Index)
		if !(f.OmitEmpty && fval.IsZero()) && !f.PrimaryKey {
			setClause = append(setClause, fmt.Sprintf("%s = ?", f.Name))
			args = append(args, fval.Interface())
		}
		if f.PrimaryKey {
			idValue = fval.Interface()
		}
	}

	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s = ?",
		r.dd.TableName,
		strings.Join(setClause, ", "),
		r.dd.ID.Name)

	args = append(args, idValue)

	_, err := FromContext(ctx).ExecContext(ctx, query, args...)
	return err
}

// Delete removes a record from the database
func (r *Repository[T]) Delete(ctx context.Context, model T) error {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.delete")
	defer span.End()

	query := fmt.Sprintf("DELETE FROM %s WHERE %s = ?", r.dd.TableName, r.dd.ID.Name)

	v := reflect.ValueOf(model)
	if v.Type().Kind() == reflect.Pointer {
		v = v.Elem()
	}

	_, err := FromContext(ctx).ExecContext(ctx, query, v.Field(r.dd.ID.Index).Interface())
	return err
}

// Count returns the total number of records in the table
func (r *Repository[T]) Count(ctx context.Context) (int, error) {
	ctx, span := otel.GetTracerProvider().Tracer("tracks").Start(ctx, "repository.count")
	defer span.End()

	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", r.dd.TableName)

	rows, err := FromContext(ctx).QueryContext(ctx, query)
	if err != nil {
		return 0, err
	}
	defer rows.Close()

	if !rows.Next() {
		return 0, fmt.Errorf("failed to get count from %s", r.dd.TableName)
	}

	var count int
	if err := rows.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}
